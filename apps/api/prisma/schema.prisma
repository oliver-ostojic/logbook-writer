generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id                   Int                      @id @default(autoincrement())
  storeId              Int?
  code                 String                   @unique
  displayName          String
  AssignmentType AssignmentType
  blockSizeMinutes     Int
  isUniversal          Boolean                  @default(false)
  isCoverageRole       Boolean                  @default(false)
  isBreakRole          Boolean                  @default(false)
  isParkingRole        Boolean                  @default(false)
  isConsecutive        Boolean                  @default(false)
  allowOutsideStoreHours Boolean                 @default(false)
  minMinutesPerCrew    Int?
  maxMinutesPerCrew    Int?
  minSegments   Int
  maxSegments   Int
  family               String?
  CoverageWindow       CoverageWindow[]
  CrewRole             CrewRole[]
  CrewRoleRequirement  CrewRoleRequirement[]
  Store                Store?                   @relation(fields: [storeId], references: [id])
}

model Store {
  id                           Int                   @id
  name                         String
  timezone                     String                @default("EST")

  /// Scheduling grid + store hours (used by solver)
  baseSlotMinutes              Int                   @default(30)   // size of one slot in minutes
  openMinutesFromMidnight      Int                   @default(420)  // 7:00 AM = 7*60
  closeMinutesFromMidnight     Int                   @default(1320) // 10:00 PM = 22*60

  /// Break policy (used by solver)
  minShiftMinutesForBreak      Int                   @default(360)  // 6h shift requires break
  breakWindowStartOffsetMinutes Int                  @default(180)  // break window starts 3h into shift
  breakWindowEndOffsetMinutes  Int                   @default(270)  // break window ends 4.5h into shift

  // Existing fields you already had
  startRegHour                 Int                   @default(480)
  endRegHour                   Int                   @default(1260)
  consecutiveProdWeight        Int                   @default(3)
  consecutiveRegWeight         Int                   @default(3)
  earlyBreakWeight             Int                   @default(3)
  lateBreakWeight              Int                   @default(3)
  productFirstHourWeight       Int                   @default(3)
  productTaskWeight            Int                   @default(3)
  registerFirstHourWeight      Int                   @default(3)
  registerTaskWeight           Int                   @default(3)

  CoverageWindow               CoverageWindow[]
  Crew                         Crew[]
  CrewRoleRequirement          CrewRoleRequirement[]
  HourlyRequirement            HourlyRequirement[]
  logbooks                     Logbook[]
  Role                         Role[]
}

model Logbook {
  id             String        @id @db.Uuid
  date           DateTime
  storeId        Int
  status         LogbookStatus
  generatedAt    DateTime
  storedFilePath String?
  metadata       Json?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  store          Store         @relation(fields: [storeId], references: [id])
  Run            Run[]
  tasks          Task[]

  @@unique([storeId, date, status], name: "uniq_store_date_status")
}

model Task {
  id        String     @id @db.Uuid
  logbookId String     @db.Uuid
  crewId    String     @db.Char(7)
  type      TaskType
  startTime DateTime
  endTime   DateTime
  origin    TaskOrigin @default(ENGINE)
  locked    Boolean    @default(false)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  crew      Crew       @relation(fields: [crewId], references: [id])
  logbook   Logbook    @relation(fields: [logbookId], references: [id])

  @@index([crewId, startTime])
}

model Run {
  id             String    @id @db.Uuid
  date           DateTime
  storeId        Int
  engine         String
  seed           Int
  status         RunStatus
  runtimeMs      Int
  violations     Json
  objectiveScore Int?
  mipGap         Float?
  logbookId      String?   @db.Uuid
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  logbook        Logbook?  @relation(fields: [logbookId], references: [id])

  @@index([storeId, date])
}

model CoverageWindow {
  id              Int      @id @default(autoincrement())
  storeId         Int
  date            DateTime
  roleId          Int
  startHour       Int
  endHour         Int
  requiredPerHour Int      @default(1)
  createdAt       DateTime @default(now())
  updatedAt       DateTime
  Role            Role     @relation(fields: [roleId], references: [id])
  Store           Store    @relation(fields: [storeId], references: [id])

  @@unique([storeId, date, roleId])
  @@index([storeId, date])
}

model Crew {
  id                     String                   @id @db.Char(7)
  name                   String
  storeId                Int
  shiftStartMin          Int                      @default(0)
  shiftEndMin            Int                      @default(0)
  prefBreakTiming        Int?
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  prefFirstHour          PrefenceTask?
  prefTask               PrefenceTask?
  BankedPreference       BankedPreference[]
  Store                  Store                    @relation(fields: [storeId], references: [id])
  CrewRole               CrewRole[]
  CrewRoleRequirement    CrewRoleRequirement[]
  PreferenceSatisfaction PreferenceSatisfaction[]
  tasks                  Task[]
}

model CrewRole {
  crewId             String   @db.Char(7)
  roleId             Int
  assignedAt         DateTime @default(now())
  specializationType String?
  crewName           String
  roleName           String
  Crew               Crew     @relation(fields: [crewId], references: [id])
  Role               Role     @relation(fields: [roleId], references: [id])

  @@id([crewId, roleId])
}

model CrewRoleRequirement {
  id            Int      @id @default(autoincrement())
  storeId       Int
  date          DateTime
  crewId        String   @db.Char(7)
  roleId        Int
  requiredHours Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime
  Crew          Crew     @relation(fields: [crewId], references: [id])
  Role          Role     @relation(fields: [roleId], references: [id])
  Store         Store    @relation(fields: [storeId], references: [id])

  @@unique([storeId, date, crewId, roleId])
  @@index([storeId, date])
}

model HourlyRequirement {
  id                  Int      @id @default(autoincrement())
  storeId             Int
  date                DateTime
  hour                Int
  requiredRegister    Int      @default(0)
  requiredProduct     Int      @default(0)
  requiredParkingHelm Int      @default(0)
  createdAt           DateTime @default(now())
  updatedAt           DateTime
  Store               Store    @relation(fields: [storeId], references: [id])

  @@unique([storeId, date, hour])
}

model PreferenceSatisfaction {
  id                      Int      @id @default(autoincrement())
  crewId                  String   @db.Char(7)
  date                    DateTime
  logbookId               String   @db.Uuid
  firstHourSatisfaction   Float    @default(0)
  taskSatisfaction        Float    @default(0)
  breakTimingSatisfaction Float    @default(0)
  overallSatisfaction     Float    @default(0)
  firstHourMet            Boolean  @default(false)
  taskPrefMet             Boolean  @default(false)
  breakTimingMet          Boolean  @default(false)
  adaptiveBoost           Float    @default(1.0)
  fairnessAdjustment      Float    @default(0)
  createdAt               DateTime @default(now())
  Crew                    Crew     @relation(fields: [crewId], references: [id])

  @@unique([crewId, date, logbookId])
  @@index([crewId, date])
  @@index([date])
}

model BankedPreference {
  id              Int            @id @default(autoincrement())
  crewId          String         @db.Char(7)
  preferenceType  PreferenceType
  preferenceValue String
  weight          Int
  originalDate    DateTime
  expiresAt       DateTime
  usedDate        DateTime?
  status          BankingStatus  @default(ACTIVE)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  Crew            Crew           @relation(fields: [crewId], references: [id])

  @@index([crewId, status])
  @@index([crewId, expiresAt])
}

enum RunStatus {
  QUEUED
  RUNNING
  FEASIBLE
  OPTIMAL
  TIME_LIMIT
  INFEASIBLE
  FAILED
  CANCELED
}

enum LogbookStatus {
  DRAFT
  PUBLISHED
  SUPERSEDED
}

enum TaskType {
  REGISTER
  PRODUCT
  PARKING_HELM
  ORDER_WRITER
  ART
  MEAL_BREAK
  TRUCK
  DEMO
  WINE_DEMO
}

enum TaskOrigin {
  ENGINE
  MANUAL
  IMPORT
}

enum PrefenceTask {
  REGISTER
  PRODUCT
}

enum AssignmentType {
  UNIVERSAL        // No constraints, can be assigned to anyone anytime (REGISTER, PRODUCT, PARKING_HELM, MEAL_BREAK)
  COVERAGE_WINDOW  // Need N crew during time window, solver picks who (DEMO, WINE_DEMO)
  CREW_SPECIFIC    // Specific crew must do this role for X hours (ORDER_WRITER, ART)
}

enum PreferenceType {
  FIRST_HOUR
  TASK
  BREAK_TIMING
  CONSECUTIVE
}

enum BankingStatus {
  ACTIVE
  USED
  EXPIRED
  CANCELED
}
