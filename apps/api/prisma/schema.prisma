// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ENUMS

enum RunStatus {
  QUEUED
  RUNNING
  FEASIBLE
  OPTIMAL
  TIME_LIMIT
  INFEASIBLE
  FAILED
  CANCELED
}

enum LogbookStatus {
  DRAFT
  PUBLISHED
  SUPERSEDED
}

enum TaskType {
  REGISTER
  PRODUCT
  PARKING_HELM
  ORDER_WRITER
  ART
  MEAL_BREAK
  TRUCK
  DEMO
  WINE_DEMO
}

enum TaskOrigin {
  ENGINE
  MANUAL
  IMPORT
}

// MODELS
// Core Domain

model CrewMember {
  id                   String                 @id @db.Char(7)
  name                 String
  storeId              Int
  store                Store                  @relation(fields: [storeId], references: [id])
  roles                CrewMemberRole[]
  // Preference weights (relative priority tiers)
  prefFirstHourWeight      Int?
  prefTaskWeight           Int?
  prefBlocksizeProdWeight  Int?
  prefBlocksizeRegWeight   Int?
  // Preference values (desired targets)
  prefFirstHour            TaskType?
  prefTask                 TaskType?
  prefBlocksizeProd        Int?
  prefBlocksizeReg         Int?
  tasks                Task[]
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  // Possible exemption for certain tasks
  canBreak             Boolean                @default(true)
  canParkingHelms      Boolean                @default(true)
}

model Role {
  id          String           @id @default(uuid()) @db.Uuid
  name        String           @unique
  crewMembers CrewMemberRole[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
}

model CrewMemberRole {
  crewMemberId String     @db.Char(7)
  crewMember   CrewMember @relation(fields: [crewMemberId], references: [id])
  roleId       String     @db.Uuid
  role         Role       @relation(fields: [roleId], references: [id])
  assignedAt   DateTime   @default(now())

  @@id([crewMemberId, roleId])
}

// Store and per-hour rules for a given date

model Store {
  id               Int            @id
  name             String
  minRegisterHours Int
  maxRegisterHours Int
  crewMembers      CrewMember[]
  hourRules        StoreHourRule[]
  logbooks         Logbook[]
  // Default register window for the store as minutes since midnight
  // 08:00 -> 480, 21:00 -> 1260
  regHoursStartMin Int            @default(480)
  regHoursEndMin   Int            @default(1260)
}

model StoreHourRule {
  id                String   @id @db.Uuid
  storeId           Int
  store             Store    @relation(fields: [storeId], references: [id])
  date              DateTime
  hour              Int
  requiredRegisters Int
  minProduct        Int?
  minParking        Int
  maxParking        Int?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([storeId, date, hour])
}

// Daily task schedule

model Logbook {
  id             String        @id @db.Uuid
  date           DateTime
  storeId        Int
  store          Store         @relation(fields: [storeId], references: [id])
  status         LogbookStatus
  generatedAt    DateTime
  storedFilePath String?
  tasks          Task[]
  metadata       Json?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  Run            Run[]

  // Only one active published logbook is allowed per store/date
  @@unique([storeId, date, status], name: "uniq_store_date_status")
}

model Task {
  id        String     @id @db.Uuid
  logbookId String     @db.Uuid
  logbook   Logbook    @relation(fields: [logbookId], references: [id])
  crewId    String     @db.Char(7)
  crew      CrewMember @relation(fields: [crewId], references: [id])
  type      TaskType
  startTime DateTime
  endTime   DateTime
  origin    TaskOrigin @default(ENGINE)
  locked    Boolean    @default(false)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([crewId, startTime])
}

model Run {
  id             String    @id @db.Uuid
  date           DateTime
  storeId        Int
  engine         String
  seed           Int
  status         RunStatus
  runtimeMs      Int
  violations     Json
  objectiveScore Int?
  mipGap         Float?
  logbookId      String?   @db.Uuid
  logbook        Logbook?  @relation(fields: [logbookId], references: [id])
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([storeId, date])
}
// For DEMO coverage (Ability to select a time window for a role to be satisfied each hour)
model RoleCoverageWindow {
  id              String   @id @db.Uuid
  date            DateTime @db.Date
  storeId         Int
  roleId          String   @db.Uuid
  windowStart     DateTime
  windowEnd       DateTime
  requiredPerHour Int
  // For Audit
  createdBy       String // user_id of MATE

  @@unique([date, storeId, roleId])
  @@index([storeId, date])
  @@map("DailyRoleCoverage")
}

model DailyRoleRequirement {
  id            String   @id @db.Uuid
  date          DateTime @db.Date
  storeId       Int
  crewId        String   @db.Char(7)
  roleId        String   @db.Uuid
  requiredHours Int

  @@unique([date, storeId, crewId, roleId])
  @@index([storeId, date])
}
